function twilightzonePreparation(Ue,Ve,Pe,filename)
%===========================================================================
% This function computes the derivatives of the given Exact solutions,and
% generate a filename.edp file for the FreeFEM++ code to use.
%
% by Longfei Li 12132015
%===========================================================================

% Input:
%    Ue: a string that defines the exact u solution
%    Ve: a string that defines the exact v solution
%    Pe: a string that defines the exact p solution
%    nb: number of boundaries of the domain
%    filename: name of the output .edp file

% Output:
%   filename.edp file that contains the definitions of FF++ functions
  
syms x y t;
syms rho mu;
syms ns;          % option to switch between N-S and stokes equations
syms fx fy ft a;  % for trig functions

Ue = sym(Ue);
Ve = sym(Ve);
Pe = sym(Pe);

% compute the derivatives
Uet = diff(Ue,t);
Vet = diff(Ve,t);  
Uex = diff(Ue,x);  
Uey = diff(Ue,y);  
Vex = diff(Ve,x);  
Vey = diff(Ve,y);  
Pex = diff(Pe,x);  
Pey = diff(Pe,y);

Uexx = diff(Uex,x);
Ueyy = diff(Uey,y);
Vexx = diff(Vex,x);
Veyy = diff(Vey,y);


% check if given exact solutions are divergence free
divU = Uex+Vey;
if divU~=0
    fprintf('MATLAB Error: Fluid velocity of the exact solution is not divergence free');
    return
end


% Pexx = diff(Pex,x);
% Peyy = diff(Pey,y);
% Pexy = diff(Pex,y);


fU = rho*Uet+Pex-mu*(Uexx+Ueyy)+ns*rho*(Ue*Uex+Ve*Uey);
fV = rho*Vet+Pey-mu*(Vexx+Veyy)+ns*rho*(Ue*Vex+Ve*Vey);

fP = diff(fU,x)+diff(fV,y);


% convert from sym to char for ouput
Exact.ueFunc = char(Ue);
Exact.veFunc = char(Ve);
Exact.uetFunc = char(Uet);
Exact.vetFunc = char(Vet);
Exact.peFunc = char(Pe);
Exact.fuFunc = char(fU);
Exact.fvFunc = char(fV);
Exact.fpFunc = char(fP);

fields = fieldnames(Exact);

filename = strcat(filename,'.edp');
fprintf('MATLAB: Generating %s\n',filename);

fid = fopen(filename,'w'); % discard existiing contents.
fprintf(fid,'//================DO NOT MODIFY===========================\n');
fprintf(fid,'//This script was generated by twilightzonePreparation.m \n');
fprintf(fid,strcat('//',datestr(now),'\n'));
fprintf(fid,'//========================================================\n');
fprintf(fid,'\n\n\n');


% write Exact solutions and forcing functions 
for i=1:numel(fields)
    fprintf(fid,'func real[int] %s(real t)\n{\n',fields{i});
    fprintf(fid,'Vh ff = %s;\n\n',Exact.(fields{i}));
    fprintf(fid,'return ff[];\n}');
 
    fprintf(fid,'\n\n\n');
end

% write initial functions
fprintf(fid,'func real[int] u0Func(real t)\n{\n');
fprintf(fid,'return ueFunc(t);\n}');
fprintf(fid,'\n\n\n');

fprintf(fid,'func real[int] v0Func(real t)\n{\n');
fprintf(fid,'return veFunc(t);\n}');
fprintf(fid,'\n\n\n');

fprintf(fid,'func real[int] p0Func(real t)\n{\n');
fprintf(fid,'return peFunc(t);\n}');
fprintf(fid,'\n\n\n');

% write boundary functions
fprintf(fid,'func real[int] ubFunc(real t)\n{\n');
fprintf(fid,'real[int] ff(Vh.ndof); ff=ueFunc(t);\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'rv[gIndex] = ff[gIndex];\n');
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');

fprintf(fid,'func real[int] vbFunc(real t)\n{\n');
fprintf(fid,'real[int] ff(Vh.ndof); ff=veFunc(t);\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'rv[gIndex] = ff[gIndex];\n');
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');


fprintf(fid,'func real[int] ubtFunc(real t)\n{\n');
fprintf(fid,'real[int] ff(Vh.ndof); ff=uetFunc(t);\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'rv[gIndex] = ff[gIndex];\n');
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');

fprintf(fid,'func real[int] vbtFunc(real t)\n{\n');
fprintf(fid,'real[int] ff(Vh.ndof); ff=vetFunc(t);\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'rv[gIndex] = ff[gIndex];\n');
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');

fclose(fid);

return





