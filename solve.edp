/*
This file solves the INS equation from t0 to tf

by Longfei Li 12102015
*/

include "defineGetDUDT.edp"   // this file defines getDUDT macros for u,v eqns

tplot = min(tplot,tf);    // make sure tplot is smaller, otherwise just plot at tf
int step=0.;              // computation step
int pstep=tplot/dt;       // plot step
dt = tplot/pstep;         // adjust dt
int nstep = tf/dt+0.5;    // total number of steps

// Divergence Damping
real alpha=0.;
if(dd){alpha=100.*mu/(h[].min*h[].min*rho);}  


if(saveDataForMATLAB)
{

real[int] timeInfo=[t0,dt,tplot,tf];
string comment="timeInfo=[t0,dt,tplot,tf]";
 writeRealArrayToMFile(timeInfo,timeInfo.n,comment,"timeInfo",dataFolderName);
}


// save runtime info to logFile
string info="Stokes, ";
if(NS){info="N-S, ";}
if(WABE){info=info+"WABE bc, ";}
else{info=info+"TN bc, ";}
if(dd){info=info+"dd ";}
else{info=info+"nodd ";}
if(periodic){info=info+", periodic ";}

{// write basic info to log file:
  ofstream oFile(logFile,append);
  oFile << "PDE info: " << info << endl;
  oFile << "Parameters: " << "mu="<< mu << ", rho="<< rho << endl;
  oFile << "timestepping method: " << ts << endl;
  if(dd)
    {
      oFile << "Divergence damping parameter alpha=" << alpha << endl;
    }
  oFile << "FEM info: " << "pn="<< pn << endl;
  oFile << "Mesh info:" << "mesh name=" << meshName 
	<< ", splitNumber="<<splitNumber<< ", nv="<<  Th.nv 
	<< ", nt="<<  Th.nt << endl;
  oFile << "Degrees of freedom: " <<"ndof="<< Vh.ndof 
	<< ", ndofK="<<  Vh.ndofK <<", nt="<< Vh.nt << endl;
  oFile << "max(h)=" << h[].max << ", min(h)=" << h[].min << endl;
  if(isTwilightzone)
    {
      oFile << "TwilightZone Info: a=" << a << ", fx=" << fx << ", ft=" << ft << endl;
    }
  oFile << "time-step info: ";
  oFile <<"nstep=" << nstep << ", cfl="<< cfl <<", t0= "<< t0 << ", dt="<< dt << ", tplot=" << tplot << ", tf="<< tf << endl;
  oFile << "\nBegin solving------->\n";
}// 




cout << "dt=" << dt << endl;

// define finite element functions for solutions and rhs
int numberOfTimeLevels = 3; // save solutions for 3 time levels;
Vh[int] uh(numberOfTimeLevels);
Vh[int] vh(numberOfTimeLevels);
Vh[int] ph(numberOfTimeLevels);
Vh[int] invisu(numberOfTimeLevels); // invisid part of dudt
Vh[int] invisv(numberOfTimeLevels); // invisid part of dvdt
Vh[int] visu(numberOfTimeLevels); // viscous part of dudt
Vh[int] visv(numberOfTimeLevels); // viscous part of dvdt
real[int] t(3);  // 3 time levels;

//forcing functions
Vh fu = 0.;   // forcing function of the u equation
Vh fv = 0.;   // forcing function of the v equation
Vh fp = 0.;   // forcing function of the p equation


//Define exact solutions and errors here for all runs.
//If there are no exact solutions, these won't be used, but they are still
//defined because ff++ lacks the ability to control varible scope.
Vh ue = 0.;
Vh ve = 0.;
Vh pe = 0.;
Vh erru = 0.;
Vh errv = 0.;
Vh errp = 0.;
Vh div = 0.;
Vh curl = 0.;
real divL2=0.;



int prev,cur,new; //define time levels
// Initial conditions
cur=step%numberOfTimeLevels;
new=(step+1)%numberOfTimeLevels;
prev=(step+2)%numberOfTimeLevels;
include "initialConditions.edp"

for(step; step<=nstep;step++)
{
cur=step%numberOfTimeLevels;
new=(step+1)%numberOfTimeLevels;
prev=(step+2)%numberOfTimeLevels;

t[new]= t0 + (step+1)*dt;

real stepTimer = clock();
include "advance.edp"
stepTimer = clock()-stepTimer;
// cout << " current time = " << t[cur] << ", Computational time for step " << step+1 <<" : " << stepTimer << endl;

// report current time every 20 steps
if(step%20==0)
{
cout << "current time = " << t[cur] << endl;
 {// write log file:
   ofstream oFile(logFile,append);
   oFile <<"step="<<step <<", current time = " << t[cur] << ", stepTimer=" <<stepTimer << "(s)" << endl;;
 }
}

if((step%pstep)==0)
{
// plot solutions, div, errors(if tz) and save a copy of eps file.
int counter = step/pstep;
include "plotOrSaveResults.edp"  
}
}

// output error to file for tz tests.
include "writeErrorToFile.edp"


