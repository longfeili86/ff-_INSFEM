//================DO NOT MODIFY===========================
//This script was generated by twilightzonePreparation.m 
//30-Aug-2016 16:01:01
//========================================================



func real[int] ueFunc(real t)
{
Vh ff = a*sin(pi*fx*x)*sin(pi*fx*y)*cos(pi*ft*t);

return ff[];
}


func real[int] veFunc(real t)
{
Vh ff = a*cos(pi*ft*t)*cos(pi*fx*x)*cos(pi*fx*y);

return ff[];
}


func real[int] uetFunc(real t)
{
Vh ff = -pi*a*ft*sin(pi*fx*x)*sin(pi*fx*y)*sin(pi*ft*t);

return ff[];
}


func real[int] vetFunc(real t)
{
Vh ff = -pi*a*ft*cos(pi*fx*x)*cos(pi*fx*y)*sin(pi*ft*t);

return ff[];
}


func real[int] peFunc(real t)
{
Vh ff = a*sin(pi*fx*x)*cos(pi*ft*t)*cos(pi*fy*y);

return ff[];
}


func real[int] fuFunc(real t)
{
Vh ff = ns*rho*(pi*a^2*fx*sin(pi*fx*x)*cos(pi*ft*t)^2*cos(pi*fx*x)*cos(pi*fx*y)^2 + pi*a^2*fx*sin(pi*fx*x)*sin(pi*fx*y)^2*cos(pi*ft*t)^2*cos(pi*fx*x)) + pi*a*fx*cos(pi*ft*t)*cos(pi*fx*x)*cos(pi*fy*y) + 2*pi^2*a*fx^2*mu*sin(pi*fx*x)*sin(pi*fx*y)*cos(pi*ft*t) - pi*a*ft*rho*sin(pi*fx*x)*sin(pi*fx*y)*sin(pi*ft*t);

return ff[];
}


func real[int] fvFunc(real t)
{
Vh ff = 2*pi^2*a*fx^2*mu*cos(pi*ft*t)*cos(pi*fx*x)*cos(pi*fx*y) - pi*a*fy*sin(pi*fx*x)*sin(pi*fy*y)*cos(pi*ft*t) - ns*rho*(pi*a^2*fx*sin(pi*fx*y)*cos(pi*ft*t)^2*cos(pi*fx*x)^2*cos(pi*fx*y) + pi*a^2*fx*sin(pi*fx*x)^2*sin(pi*fx*y)*cos(pi*ft*t)^2*cos(pi*fx*y)) - pi*a*ft*rho*cos(pi*fx*x)*cos(pi*fx*y)*sin(pi*ft*t);

return ff[];
}


func real[int] fpFunc(real t)
{
Vh ff = ns*rho*(pi^2*a^2*fx^2*cos(pi*ft*t)^2*cos(pi*fx*x)^2*cos(pi*fx*y)^2 - pi^2*a^2*fx^2*sin(pi*fx*x)^2*cos(pi*ft*t)^2*cos(pi*fx*y)^2 + pi^2*a^2*fx^2*sin(pi*fx*y)^2*cos(pi*ft*t)^2*cos(pi*fx*x)^2 - pi^2*a^2*fx^2*sin(pi*fx*x)^2*sin(pi*fx*y)^2*cos(pi*ft*t)^2) - ns*rho*(pi^2*a^2*fx^2*cos(pi*ft*t)^2*cos(pi*fx*x)^2*cos(pi*fx*y)^2 + pi^2*a^2*fx^2*sin(pi*fx*x)^2*cos(pi*ft*t)^2*cos(pi*fx*y)^2 - pi^2*a^2*fx^2*sin(pi*fx*y)^2*cos(pi*ft*t)^2*cos(pi*fx*x)^2 - pi^2*a^2*fx^2*sin(pi*fx*x)^2*sin(pi*fx*y)^2*cos(pi*ft*t)^2) - pi^2*a*fx^2*sin(pi*fx*x)*cos(pi*ft*t)*cos(pi*fy*y) - pi^2*a*fy^2*sin(pi*fx*x)*cos(pi*ft*t)*cos(pi*fy*y);

return ff[];
}


func real[int] u0Func(real t)
{
return ueFunc(t);
}


func real[int] v0Func(real t)
{
return veFunc(t);
}


func real[int] p0Func(real t)
{
return peFunc(t);
}


func real[int] ubFunc(real t)
{
real[int] ff(Vh.ndof); ff=ueFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


func real[int] vbFunc(real t)
{
real[int] ff(Vh.ndof); ff=veFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


func real[int] ubtFunc(real t)
{
real[int] ff(Vh.ndof); ff=uetFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


func real[int] vbtFunc(real t)
{
real[int] ff(Vh.ndof); ff=vetFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


