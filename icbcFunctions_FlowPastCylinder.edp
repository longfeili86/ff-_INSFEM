//================DO NOT MODIFY===========================
//This script was generated by icbcPreparation.m 
//17-Oct-2018 01:04:36
//========================================================



func real[int] u0Func(real t)
{
Vh ff = 0;
return ff[];
}


func real[int] v0Func(real t)
{
Vh ff = 0;
return ff[];
}


func real[int] p0Func(real t)
{
Vh ff = 0;
return ff[];
}


func real ub1Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real ubt1Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vb1Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vbt1Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real ub2Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0.41^(-2)*sin(pi*t/8)*(6*y*(0.41-y));
return rv;
}


func real ubt2Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = -4.4616299821534800713860797144557*y*pi*cos((t*pi)/8)*(y - 0.41);
return rv;
}


func real vb2Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vbt2Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real ub3Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real ubt3Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vb3Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vbt3Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real ub4Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0.41^(-2)*sin(pi*t/8)*(6*y*(0.41-y));
return rv;
}


func real ubt4Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = -4.4616299821534800713860797144557*y*pi*cos((t*pi)/8)*(y - 0.41);
return rv;
}


func real vb4Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vbt4Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real ub5Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real ubt5Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vb5Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real vbt5Func(real t,real x, real y)
{
//Warning: x and y are reserved varible in FEM++ but it seems working ok here.
real rv=0.;
rv = 0;
return rv;
}


func real[int] ubFunc(real t)
{
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
int bNumber = lb[][gIndex]; //Boundary number
real xx=Px[gIndex]; //x coordinate of the point
real yy=Py[gIndex]; //y coordinate of the point
if (bNumber==1){
rv[gIndex]=ub1Func(t,xx,yy);
}
if (bNumber==2){
rv[gIndex]=ub2Func(t,xx,yy);
}
if (bNumber==3){
rv[gIndex]=ub3Func(t,xx,yy);
}
if (bNumber==4){
rv[gIndex]=ub4Func(t,xx,yy);
}
if (bNumber==5){
rv[gIndex]=ub5Func(t,xx,yy);
}
}
return rv;
}


func real[int] ubtFunc(real t)
{
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
int bNumber = lb[][gIndex]; //Boundary number
real xx=Px[gIndex]; //x coordinate of the point
real yy=Py[gIndex]; //y coordinate of the point
if (bNumber==1){
rv[gIndex]=ubt1Func(t,xx,yy);
}
if (bNumber==2){
rv[gIndex]=ubt2Func(t,xx,yy);
}
if (bNumber==3){
rv[gIndex]=ubt3Func(t,xx,yy);
}
if (bNumber==4){
rv[gIndex]=ubt4Func(t,xx,yy);
}
if (bNumber==5){
rv[gIndex]=ubt5Func(t,xx,yy);
}
}
return rv;
}


func real[int] vbFunc(real t)
{
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
int bNumber = lb[][gIndex]; //Boundary number
real xx=Px[gIndex]; //x coordinate of the point
real yy=Py[gIndex]; //y coordinate of the point
if (bNumber==1){
rv[gIndex]=vb1Func(t,xx,yy);
}
if (bNumber==2){
rv[gIndex]=vb2Func(t,xx,yy);
}
if (bNumber==3){
rv[gIndex]=vb3Func(t,xx,yy);
}
if (bNumber==4){
rv[gIndex]=vb4Func(t,xx,yy);
}
if (bNumber==5){
rv[gIndex]=vb5Func(t,xx,yy);
}
}
return rv;
}


func real[int] vbtFunc(real t)
{
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
int bNumber = lb[][gIndex]; //Boundary number
real xx=Px[gIndex]; //x coordinate of the point
real yy=Py[gIndex]; //y coordinate of the point
if (bNumber==1){
rv[gIndex]=vbt1Func(t,xx,yy);
}
if (bNumber==2){
rv[gIndex]=vbt2Func(t,xx,yy);
}
if (bNumber==3){
rv[gIndex]=vbt3Func(t,xx,yy);
}
if (bNumber==4){
rv[gIndex]=vbt4Func(t,xx,yy);
}
if (bNumber==5){
rv[gIndex]=vbt5Func(t,xx,yy);
}
}
return rv;
}


//Write some unused functions to file to make both tz and non-tz
//tests work thanks to the FF++ syntax.

func real[int] ueFunc(real t)
{
Vh ff = 0;

return ff[];
}


func real[int] veFunc(real t)
{
Vh ff = 0;

return ff[];
}


func real[int] peFunc(real t)
{
Vh ff = 0;

return ff[];
}


func real[int] fuFunc(real t)
{
Vh ff = 0;

return ff[];
}


func real[int] fvFunc(real t)
{
Vh ff = 0;

return ff[];
}


func real[int] fpFunc(real t)
{
Vh ff = 0;

return ff[];
}


