function icbcPreparation(Uib,Vib,Pib,nb,filename)
%===========================================================================
% This function writes the specified initial and boundary conditions
% Uib,Vib into filename.edp file for FF++ code to use
%
% by Longfei Li 12142015
% major modification by Longfei Li 10092018
%===========================================================================

% Input:
%    Uib: an array of strings that defines i&b functions: u0, u1,... un. 
%    Vib: an array of strings that defines i&b functions: v0, v1,... vn.
%    Pib: an array of strings that defines i&b functions: p0 for now....
%     nb: number of boundaries of the domain
%    filename: name of the output .edp file

% Output:
%   filename.edp file that contains the definitions of FF++ functions
  
if(length(Uib)~=nb+1 || length(Vib)~=nb+1 )
    fprintf('MATLAB: the number of bc for U or for V does not match the number of boundaries.\n');
    fprintf('Please specify 1 ic and %d bcs for each of U and V\n',nb);
end



filename = strcat(filename,'.edp');
fprintf('MATLAB: Generating %s\n',filename);

fid = fopen(filename,'w'); % discard existing contents.
fprintf(fid,'//================DO NOT MODIFY===========================\n');
fprintf(fid,'//This script was generated by icbcPreparation.m \n');
fprintf(fid,strcat('//',datestr(now),'\n'));
fprintf(fid,'//========================================================\n');
fprintf(fid,'\n\n\n');


% write initial functions
fprintf(fid,'func real[int] u0Func(real t)\n{\n');
fprintf(fid,'Vh ff = %s;\n',Uib{1});
fprintf(fid,'return ff[];\n}');
fprintf(fid,'\n\n\n');

fprintf(fid,'func real[int] v0Func(real t)\n{\n');
fprintf(fid,'Vh ff = %s;\n',Vib{1});
fprintf(fid,'return ff[];\n}');
fprintf(fid,'\n\n\n');

fprintf(fid,'func real[int] p0Func(real t)\n{\n');
fprintf(fid,'Vh ff = %s;\n',Pib{1});
fprintf(fid,'return ff[];\n}');
fprintf(fid,'\n\n\n');

% write boundary functions

syms x y t; % needed to compute time derivative of boundary functions

for i=1:nb
    fprintf(fid,'func real ub%dFunc(real t,real x, real y)\n{\n',i);
    fprintf(fid,'//Warning: x and y are reserved varible in FEM++ but it seems working ok here.\n');
    fprintf(fid,'real rv=0.;\n');
    fprintf(fid,'rv = %s;\n',Uib{i+1});
    fprintf(fid,'return rv;\n}');
    fprintf(fid,'\n\n\n');
    
    ubSym=sym(Uib{i+1});
    ubtSym=diff(ubSym,t);
    ubt=char(ubtSym);
    fprintf(fid,'func real ubt%dFunc(real t,real x, real y)\n{\n',i);
    fprintf(fid,'//Warning: x and y are reserved varible in FEM++ but it seems working ok here.\n');
    fprintf(fid,'real rv=0.;\n');
    fprintf(fid,'rv = %s;\n',ubt);
    fprintf(fid,'return rv;\n}');
    fprintf(fid,'\n\n\n');

    

    fprintf(fid,'func real vb%dFunc(real t,real x, real y)\n{\n',i);
    fprintf(fid,'//Warning: x and y are reserved varible in FEM++ but it seems working ok here.\n');    
    fprintf(fid,'real rv=0.;\n');
    fprintf(fid,'rv = %s;\n',Vib{i+1});
    fprintf(fid,'return rv;\n}');
    fprintf(fid,'\n\n\n');
    
    vbSym=sym(Vib{i+1});
    vbtSym=diff(vbSym,t);
    vbt=char(vbtSym);
    fprintf(fid,'func real vbt%dFunc(real t,real x, real y)\n{\n',i);
    fprintf(fid,'//Warning: x and y are reserved varible in FEM++ but it seems working ok here.\n');
    fprintf(fid,'real rv=0.;\n');
    fprintf(fid,'rv = %s;\n',vbt);
    fprintf(fid,'return rv;\n}');
    fprintf(fid,'\n\n\n');

end
clear x y t; % release

% boundary condition for u
fprintf(fid,'func real[int] ubFunc(real t)\n{\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'int bNumber = lb[][gIndex]; //Boundary number\n'); 

fprintf(fid,'real xx=Px[gIndex]; //x coordinate of the point\n'); 
fprintf(fid,'real yy=Py[gIndex]; //y coordinate of the point\n');   
for b=1:nb 
    fprintf(fid,'if (bNumber==%d){\n',b);
    fprintf(fid,'rv[gIndex]=ub%dFunc(t,xx,yy);\n',b);
    fprintf(fid,'}\n');   
end
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');

% boundary condition for ut
fprintf(fid,'func real[int] ubtFunc(real t)\n{\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'int bNumber = lb[][gIndex]; //Boundary number\n'); 

fprintf(fid,'real xx=Px[gIndex]; //x coordinate of the point\n'); 
fprintf(fid,'real yy=Py[gIndex]; //y coordinate of the point\n');   
for b=1:nb 
    fprintf(fid,'if (bNumber==%d){\n',b);
    fprintf(fid,'rv[gIndex]=ubt%dFunc(t,xx,yy);\n',b);
    fprintf(fid,'}\n');   
end
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');

% boundary condition for v
fprintf(fid,'func real[int] vbFunc(real t)\n{\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'int bNumber = lb[][gIndex]; //Boundary number\n'); 

fprintf(fid,'real xx=Px[gIndex]; //x coordinate of the point\n'); 
fprintf(fid,'real yy=Py[gIndex]; //y coordinate of the point\n');   
for b=1:nb 
    fprintf(fid,'if (bNumber==%d){\n',b);
    fprintf(fid,'rv[gIndex]=vb%dFunc(t,xx,yy);\n',b);
    fprintf(fid,'}\n');   
end
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');

% boundary condition for vt
fprintf(fid,'func real[int] vbtFunc(real t)\n{\n');
fprintf(fid,'real[int] rv(Vh.ndof); rv=0.;\n');
fprintf(fid,'//loop over all the boundary points\n');
fprintf(fid,'for(int i=0;i<bNodes.n;i++){\n');
fprintf(fid,'int gIndex = bNodes[i];\n');
fprintf(fid,'int bNumber = lb[][gIndex]; //Boundary number\n'); 

fprintf(fid,'real xx=Px[gIndex]; //x coordinate of the point\n'); 
fprintf(fid,'real yy=Py[gIndex]; //y coordinate of the point\n');   
for b=1:nb 
    fprintf(fid,'if (bNumber==%d){\n',b);
    fprintf(fid,'rv[gIndex]=vbt%dFunc(t,xx,yy);\n',b);
    fprintf(fid,'}\n');   
end
fprintf(fid,'}\n');
fprintf(fid,'return rv;\n}');
fprintf(fid,'\n\n\n');


% write some unused functions to file to make both tz and non-tz tests work
% thanks to the FF++ syntax
fprintf(fid,'//Write some unused functions to file to make both tz and non-tz\n');
fprintf(fid,'//tests work thanks to the FF++ syntax.\n\n');
Exact.ueFunc = '0';
Exact.veFunc = '0';
Exact.peFunc = '0';
Exact.fuFunc = '0';
Exact.fvFunc = '0';
Exact.fpFunc = '0';
fields = fieldnames(Exact);
for i=1:numel(fields)
    fprintf(fid,'func real[int] %s(real t)\n{\n',fields{i});
    fprintf(fid,'Vh ff = %s;\n\n',Exact.(fields{i}));
    fprintf(fid,'return ff[];\n}');
 
    fprintf(fid,'\n\n\n');
end
fclose(fid);

return





