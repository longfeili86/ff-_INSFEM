//================DO NOT MODIFY===========================
//This script was generated by twilightzonePreparation.m 
//17-Dec-2015 00:31:35
//========================================================



func real[int] ueFunc(real t)
{
Vh ff = (0.5*t + 1)*(2*x*y + x^2 + y^2);

return ff[];
}


func real[int] veFunc(real t)
{
Vh ff = -(0.5*t + 1)*(2*x*y - x^2 + y^2);

return ff[];
}


func real[int] uetFunc(real t)
{
Vh ff = 1.0*x*y + 0.5*x^2 + 0.5*y^2;

return ff[];
}


func real[int] vetFunc(real t)
{
Vh ff = 0.5*x^2 - 1.0*x*y - 0.5*y^2;

return ff[];
}


func real[int] peFunc(real t)
{
Vh ff = (0.5*t + 1)*(0.5*x*y + x^2 + y^2 - 1);

return ff[];
}


func real[int] fuFunc(real t)
{
Vh ff = (2*x + 0.5*y)*(0.5*t + 1) - mu*(2.0*t + 4.0) + rho*(1.0*x*y + 0.5*x^2 + 0.5*y^2) - ns*rho*((2*x + 2*y)*(0.5*t + 1)^2*(2*x*y - x^2 + y^2) - (2*x + 2*y)*(0.5*t + 1)^2*(2*x*y + x^2 + y^2));

return ff[];
}


func real[int] fvFunc(real t)
{
Vh ff = (0.5*x + 2*y)*(0.5*t + 1) - rho*(1.0*x*y - 0.5*x^2 + 0.5*y^2) + ns*rho*((2*x + 2*y)*(0.5*t + 1)^2*(2*x*y - x^2 + y^2) + (2*x - 2*y)*(0.5*t + 1)^2*(2*x*y + x^2 + y^2));

return ff[];
}


func real[int] fpFunc(real t)
{
Vh ff = 2.0*t + ns*rho*((2*x + 2*y)^2*(0.5*t + 1)^2 - 2*(0.5*t + 1)^2*(2*x*y + x^2 + y^2) + 2*(0.5*t + 1)^2*(2*x*y - x^2 + y^2) + (2*x - 2*y)*(2*x + 2*y)*(0.5*t + 1)^2) + ns*rho*(2*(0.5*t + 1)^2*(2*x*y + x^2 + y^2) + (2*x + 2*y)^2*(0.5*t + 1)^2 - 2*(0.5*t + 1)^2*(2*x*y - x^2 + y^2) + (2*x - 2*y)*(2*x + 2*y)*(0.5*t + 1)^2) + 4.0;

return ff[];
}


func real[int] u0Func(real t)
{
return ueFunc(t);
}


func real[int] v0Func(real t)
{
return veFunc(t);
}


func real[int] p0Func(real t)
{
return peFunc(t);
}


func real[int] ubFunc(real t)
{
real[int] ff(Vh.ndof); ff=ueFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


func real[int] vbFunc(real t)
{
real[int] ff(Vh.ndof); ff=veFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


func real[int] ubtFunc(real t)
{
real[int] ff(Vh.ndof); ff=uetFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


func real[int] vbtFunc(real t)
{
real[int] ff(Vh.ndof); ff=vetFunc(t);
real[int] rv(Vh.ndof); rv=0.;
//loop over all the boundary points
for(int i=0;i<bNodes.n;i++){
int gIndex = bNodes[i];
rv[gIndex] = ff[gIndex];
}
return rv;
}


